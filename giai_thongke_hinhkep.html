<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thống kê hai mẫu số liệu</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .container {
            width: 100%;
            height: 100%;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
        }

        .form-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .form-group {
            width: 32%;
            /* Chia 3 khung cho hàng đầu tiên */
        }

        .form-row:last-child .form-group {
            width: 48%;
            /* Chia 2 khung cho hàng thứ hai */
        }

        .form-group label {
            font-weight: bold;
            color: #555;
            display: block;
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .btn {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            color: #fff;
            background-color: #28a745;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-align: center;
            margin-top: 10px;
        }

        .btn:hover {
            background-color: #218838;
        }

        .textarea-container {
            position: relative;
            margin-top: 15px;
            height: 100%;
        }

        #result {
            width: 100%;
            height: calc(100% - 10px);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            font-family: Consolas, monospace;
            resize: none;
            box-sizing: border-box;
        }
        .btn-copy {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 14px;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .btn-copy:hover {
            background-color: #0056b3;
        }
        /* CSS for the menu */
        .menu {
            display: flex;
            justify-content: center;
            background-color: #007bff;
            color: #fff;
            padding: 10px 0;
        }

        .menu a, .dropbtn {
            color: #fff;
            text-decoration: none;
            padding: 10px 20px;
            display: inline-block;
        }

        .menu a:hover, .dropbtn:hover {
            background-color: #555;
        }
    </style>
</head>

<body>
    <div class="menu">
        <a href="index.html">Home</a>
        <a href="giai_thong_ke_k10_new.html">Thống Kê 10</a>
        <a href="giai_thongke_bangdon.html">Thống Kê 12-Bảng</a>
        <a href="giai_thongke_hinhdon.html">Thống Kê 12-Biểu Đồ Cột Đơn</a>
        <a href="giai_thongke_hinhkep.html">Thống Kê 12-Biểu Đồ Cột Ghép</a>
    </div>
    <div class="container">
        <h1>Thống kê Hai Mẫu Số Liệu</h1>

        <form id="inputForm">
            <div class="form-row">
                <div class="form-group">
                    <label for="start">Số bắt đầu:</label>
                    <input type="number" id="start" name="start" required>
                </div>
                <div class="form-group">
                    <label for="ranges">Số khoảng:</label>
                    <input type="number" id="ranges" name="ranges" required>
                </div>
                <div class="form-group">
                    <label for="step">Khoảng cách:</label>
                    <input type="number" id="step" name="step" required>
                </div>
            </div>
        
            <div class="form-row">
                <div class="form-group">
                    <label for="frequenciesA">Tần số Mẫu A:</label>
                    <input type="text" id="frequenciesA" name="frequenciesA" placeholder="Ví dụ: 5,7,8,9,5" required>
                </div>
                <div class="form-group">
                    <label for="frequenciesB">Tần số Mẫu B:</label>
                    <input type="text" id="frequenciesB" name="frequenciesB" placeholder="Ví dụ: 6,9,7,9,5" required>
                </div>
            </div>
        
            <button type="button" class="btn" onclick="thongke()">Tính toán</button>
        </form>


        <div class="textarea-container">
            <textarea id="result" readonly></textarea>
            <button class="btn-copy" onclick="copyResult()">Sao chép</button>
        </div>
    
    </div>
    <!-- Hộp thoại tùy chỉnh -->
    <div id="copyDialog" class="dialog">
        <div class="dialog-content">
            <span class="close" onclick="closeDialog()">&times;</span>
            <p>Đã sao chép kết quả!</p>
        </div>
    </div>
    
    <style>
        /* Phong cách cho hộp thoại tùy chỉnh */
        .dialog {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }
    
        .dialog-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            margin: auto;
        }
    
        .close {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #aaa;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
        }
    
        .close:hover,
        .close:focus {
            color: #000;
        }
    </style>

    <script>

        function thongke() {
            let startInput = document.getElementById("start").value;
            // Chuẩn hóa startInput: Thay thế dấu phẩy bằng dấu chấm
            startInput = startInput.replace(',', '.');            
            // Kiểm tra xem start có phải là số thập phân hay không
            const start = startInput.includes('.') ? parseFloat(startInput) : parseInt(startInput);
            const ranges = parseInt(document.getElementById("ranges").value);
            const step = parseFloat(document.getElementById("step").value);
           // Tách các giá trị tần số cách nhau bằng dấu phẩy hoặc khoảng trắng
            const frequenciesA = document.getElementById("frequenciesA").value.split(/[\s,]+/).map(Number);
            const frequenciesB = document.getElementById("frequenciesB").value.split(/[\s,]+/).map(Number);
            

            
            if (frequenciesA.length !== ranges || frequenciesB.length !== ranges) {
                alert("Số lượng tần số của Mẫu A và Mẫu B phải bằng số khoảng!");
                return;
            }
            const totalStudentsA = frequenciesA.reduce((acc, freq) => acc + freq, 0);
            const totalStudentsB = frequenciesB.reduce((acc, freq) => acc + freq, 0);

            if (totalStudentsA !== totalStudentsB) {
                alert("Tổng tần số của Mẫu A và Mẫu B phải bằng nhau!");
                return;
            }

            const nMod4 = totalStudentsA % 4;

            let result;

            if (nMod4 === 0) {
                result = thongke_4k0_2cot(start, ranges, step, frequenciesA,frequenciesB);
            } else if (nMod4 === 1) {
                result = thongke_4k1_2cot(start, ranges, step, frequenciesA, frequenciesB);
            } else if (nMod4 === 2) {
                result = thongke_4k2_2cot(start, ranges, step, frequenciesA, frequenciesB);
            } else if (nMod4 === 3) {
                result = thongke_4k3_2cot(start, ranges, step, frequenciesA, frequenciesB);
            } else {
                alert("Có lỗi, liên hệ lại với tác giả xử lý.");
                return;
            }

            document.getElementById("result").value = result;
        }

        

        function thongke_4k0_2cot(start, ranges, step, frequenciesA, frequenciesB) {
            // Tạo giá trị đầu tiên của khoảng từ tham số start
            const startHeight = start;
            const numRanges = ranges;
            

            
                // Tạo các khoảng chiều cao
                const heightRanges = [];
                for (let i = 0; i < numRanges; i++) {
                    const rangeStart = startHeight + i * step;
                    const rangeEnd = rangeStart + step;
                    const isDecimal = start % 1 !== 0;  // Kiểm tra xem số bắt đầu có phải là số thập phân
                    if (isDecimal) {
                        heightRanges.push(`[${rangeStart.toFixed(1)};${rangeEnd.toFixed(1)})`);
                    } else {
                        heightRanges.push(`[${Math.round(rangeStart)};${Math.round(rangeEnd)})`);
                    }
                }
                

                // Sử dụng tần số được truyền vào thay vì tạo ngẫu nhiên
                let totalStudentsA = frequenciesA.reduce((acc, freq) => acc + freq, 0);
                let totalStudentsB = frequenciesB.reduce((acc, freq) => acc + freq, 0);

                // Hàm tính toán thống kê cho một mẫu cụ thể
                function calculateStatistics(frequencies, totalStudents, label) {
                    const representativeValues = heightRanges.map(range => {
                        const lowerBound = parseInt(range.split(";")[0].replace("[", ""));
                        const upperBound = parseInt(range.split(";")[1].replace(")", ""));
                        return (lowerBound + upperBound) / 2;
                    });

                    const mean = representativeValues.reduce((acc, value, index) => acc + value * frequencies[index], 0) / totalStudents;
                    const variance = representativeValues.reduce((acc, value, index) => acc + frequencies[index] * Math.pow(value, 2), 0) / totalStudents - Math.pow(mean, 2);
                    const standardDeviation = Math.sqrt(variance);

                    const positionQ1 = totalStudents / 4;
                    const positionQ2 = totalStudents / 2;
                    const positionQ3 = 3 * totalStudents / 4;
                    let cumulativeFrequency = 0;

                    let Q1, Q2, Q3;
                    let Q1Range, Q1Frequency, Q1PreviousCumulative;
                    let Q2Range, Q2Frequency, Q2PreviousCumulative;
                    let Q3Range, Q3Frequency, Q3PreviousCumulative;
                    let Q1BoundaryUsed = false, Q1GroupA, Q1GroupB;
                    let Q3BoundaryUsed = false, Q3GroupA, Q3GroupB;

                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ1 && !Q1) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            if (Math.ceil(positionQ1) - 1 <= previousCumulative || Math.ceil(positionQ1) > cumulativeFrequency) {
                                Q1 = u_m;
                                Q1BoundaryUsed = true;
                                Q1GroupA = heightRanges[i - 1] || heightRanges[i];
                                Q1GroupB = heightRanges[i];
                            } else {
                                Q1 = u_m + ((positionQ1 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            }
                            Q1Range = heightRanges[i];
                            Q1Frequency = frequencies[i];
                            Q1PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ2 && !Q2) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            Q2 = u_m + ((positionQ2 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            Q2Range = heightRanges[i];
                            Q2Frequency = frequencies[i];
                            Q2PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ3 && !Q3) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            if (Math.ceil(positionQ3) <= previousCumulative || Math.ceil(positionQ3) + 1 > cumulativeFrequency) {
                                Q3 = u_m;
                                Q3BoundaryUsed = true;
                                Q3GroupA = heightRanges[i - 1] || heightRanges[i];
                                Q3GroupB = heightRanges[i];
                            } else {
                                Q3 = u_m + ((positionQ3 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            }
                            Q3Range = heightRanges[i];
                            Q3Frequency = frequencies[i];
                            Q3PreviousCumulative = previousCumulative;
                        }
                    }

                    const IQR = Q3 - Q1;
                    const lowerOutlierBound = Q1 - 1.5 * IQR;
                    const upperOutlierBound = Q3 + 1.5 * IQR;

                    const maxFrequency = Math.max(...frequencies);
                    const modeIndex = frequencies.indexOf(maxFrequency);
                    const u_m_mode = parseInt(heightRanges[modeIndex].split(";")[0].replace("[", ""));
                    const u_m1_mode = parseInt(heightRanges[modeIndex].split(";")[1].replace(")", ""));
                    const n_m = frequencies[modeIndex];
                    const n_m_1 = modeIndex > 0 ? frequencies[modeIndex - 1] : 0;
                    const n_m_1_next = modeIndex < frequencies.length - 1 ? frequencies[modeIndex + 1] : 0;
                    const mode = u_m_mode + ((n_m - n_m_1) / ((n_m - n_m_1) + (n_m - n_m_1_next))) * (u_m1_mode - u_m_mode);

                    let result = `\\textbf{${label}}: \\newline\n`;
                    result += `Số trung bình của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ \\overline{x}=\\dfrac{${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}`).join('+')}}{${totalStudents}}=\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}}\\approx ${(mean).toFixed(2)}. $$\n`;
                    result += `Phương sai của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ S^2=\\dfrac{1}{${totalStudents}}(${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}^2`).join('+')})-\\left(\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}} \\right)^2\\approx ${(variance).toFixed(2)}.  $$\n`;
                    result += `Độ lệch chuẩn của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ S\\approx\\sqrt{${(variance).toFixed(2)}}\\approx ${(standardDeviation).toFixed(2)}. $$\n`;

                    result += `Gọi $x_1$; $x_2$; \\ldots; $x_{${totalStudents}}$ là mẫu số liệu gốc gồm $${totalStudents}$ giá trị được xếp theo thứ tự không giảm. Ta có \n`;
                    result += `\\begin{itemize}\n`;
                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        result += `\\item $x_{${cumulativeFrequency - frequencies[i] + 1}}$, \\ldots, $x_{${cumulativeFrequency}} \\in [${heightRanges[i].split(";")[0].replace("[", "")};${heightRanges[i].split(";")[1].replace(")", "")})$; \n`;
                    }
                    result = result.trim();
                    result += `\n\\end{itemize}\n`;

                    // Xác định tứ phân vị thứ nhất (Q1)
                    if (Q1BoundaryUsed) {
                        result += `Tứ phân vị thứ nhất của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ1) - 1}}}$ và $x_{{${Math.ceil(positionQ1)}}}$ mà $x_{{${Math.ceil(positionQ1) - 1}}} \\in [${Q1GroupA.split(";")[0].replace("[", "")};${Q1GroupA.split(";")[1].replace(")", "")})$, $x_{{${Math.ceil(positionQ1)}}} \\in [${Q1GroupB.split(";")[0].replace("[", "")};${Q1GroupB.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ nhất của mẫu số liệu ghép nhóm là biên của nhóm sau:\n`;
                        result += `$$Q_1=${Q1GroupB.split(";")[0].replace("[", "")}$$\n`;
                    } else {
                        result += `Tứ phân vị thứ nhất của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ1) - 1}}}$ và $x_{{${Math.ceil(positionQ1)}}}$ mà $x_{{${Math.ceil(positionQ1) - 1}}}, x_{{${Math.ceil(positionQ1)}}} \\in [${Q1Range.split(";")[0].replace("[", "")};${Q1Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ nhất của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_1=${Q1Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{4}-${Q1PreviousCumulative}}{${Q1Frequency}} \\cdot(${Q1Range.split(";")[1].replace(")", "")}-${Q1Range.split(";")[0].replace("[", "")})\\approx ${(Q1).toFixed(2)}$$\n`;
                    }

                    // Xác định trung vị (Q2)
                    if (totalStudents % 4 === 0) {
                        result += `Trung vị của mẫu số liệu gốc là trung bình cộng của $x_{{${positionQ2}}}$ và $x_{{${positionQ2 + 1}}}$ mà $x_{{${positionQ2}}} \\in [${Q2Range.split(";")[0].replace("[", "")};${Q2Range.split(";")[1].replace(")", "")})$ và $x_{{${positionQ2 + 1}}}$ \\in [${Q2Range.split(";")[0].replace("[", "")};${Q2Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, trung vị của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_2=\\dfrac{x_{{${positionQ2}}}+x_{{${positionQ2 + 1}}}}{2}\\approx ${(Q2).toFixed(2)}$$\n`;
                    } else {
                        result += `Trung vị của mẫu số liệu gốc là $x_{{${Math.ceil(positionQ2)}}}$ nằm trong nhóm có khoảng $[${Q2Range.split(";")[0].replace("[", "")};${Q2Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, trung vị của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_2=${Q2Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{2}-${Q2PreviousCumulative}}{${Q2Frequency}} \\cdot(${Q2Range.split(";")[1].replace(")", "")}-${Q2Range.split(";")[0].replace("[", "")})\\approx ${(Q2).toFixed(2)}$$\n`;
                    }
                    // Xác định tứ phân vị thứ ba (Q3)
                    if (Q3BoundaryUsed) {
                        result += `Tứ phân vị thứ ba của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ3)}}}$ và $x_{{${Math.ceil(positionQ3) + 1}}}$ mà $x_{{${Math.ceil(positionQ3)}}} \\in [${Q3GroupA.split(";")[0].replace("[", "")};${Q3GroupA.split(";")[1].replace(")", "")})$, $x_{{${Math.ceil(positionQ3) + 1}}} \\in [${Q3GroupB.split(";")[0].replace("[", "")};${Q3GroupB.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ ba của mẫu số liệu ghép nhóm là biên của nhóm sau:\n`;
                        result += `$$Q_3=${Q3GroupB.split(";")[0].replace("[", "")}$$\n`;
                    } else {
                        result += `Tứ phân vị thứ ba của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ3)}}}$ mà $x_{{${Math.ceil(positionQ3)}}}, x_{{${Math.ceil(positionQ3) + 1}}}$ mà $x_{{${Math.ceil(positionQ3)}}}, x_{{${Math.ceil(positionQ3) + 1}}} \\in [${Q3Range.split(";")[0].replace("[", "")};${Q3Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ ba của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_3=${Q3Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{3\\cdot${totalStudents}}{4}-${Q3PreviousCumulative}}{${Q3Frequency}} \\cdot(${Q3Range.split(";")[1].replace(")", "")}-${Q3Range.split(";")[0].replace("[", "")})\\approx ${(Q3).toFixed(2)}$$\n`;
                    }

                    result += `Vậy khoảng tứ phân vị của mẫu số liệu ghép nhóm là $\\Delta_Q=Q_3-Q_1 \\approx ${(Q3).toFixed(2)}-${(Q1).toFixed(2)}\\approx ${(IQR).toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai thấp hơn ngưỡng dưới là $<${lowerOutlierBound.toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai cao hơn ngưỡng trên là $>${upperOutlierBound.toFixed(2)}$.\\\\\n`;

                    result += `Mốt của mẫu số liệu ghép nhóm là \n`;
                    result += `$$ M_0=${u_m_mode}+\\dfrac{${n_m}-${n_m_1}}{(${n_m}-${n_m_1})+(${n_m}-${n_m_1_next})} \\cdot(${u_m1_mode}-${u_m_mode})\\approx ${(mode).toFixed(2)}$$\n`;

                    return result;
                }

                // Kết quả cho Mẫu A
                const resultA = calculateStatistics(frequenciesA, totalStudentsA, "Mẫu A");

                // Kết quả cho Mẫu B
                const resultB = calculateStatistics(frequenciesB, totalStudentsB, "Mẫu B");
                // Tìm giá trị tần số lớn nhất
                const maxFrequency = Math.max(Math.max(...frequenciesA), Math.max(...frequenciesB)) + 1;

                // Tạo biểu đồ cột
                let barChart = `\\begin{center}\n`;
                barChart += `\\begin{tikzpicture}[>=stealth,line join=round,line cap=round,font=\\footnotesize,scale=0.85,line width=1pt]\n`;
                barChart += `\\draw[->] (0,0)--(0,${maxFrequency + 1})node[left]{(\\text{Tần Số})};\n`;
                for (let y = 1; y <= maxFrequency; y++) {
                    barChart += `\\draw[shift={(0,${y})}] (0,0)--(-2pt,0) node[left]{\\scriptsize $${y}$};\n`;
                }
                barChart += `\\path (5,${maxFrequency + 2}) node {\n`;
                barChart += `\\normalsize{\\textbf{Hai Mẫu Số Liệu $A$ và $B$}}\n`;
                barChart += `};\n`;

                for (let y = 1; y <= maxFrequency; y++) {
                    barChart += `\\draw[dashed,thin,line width=0.01pt] (0,${y})--(${numRanges * 2 + 3},${y});\n`;
                }
                barChart += `\\draw[line cap=round,pattern=north east lines] (${numRanges * 2 + 3},${maxFrequency - 1})--(${numRanges * 2 + 3},${maxFrequency})--(${numRanges * 2 + 2},${maxFrequency})--(${numRanges * 2 + 2},${maxFrequency - 1})--(${numRanges * 2 + 3},${maxFrequency - 1}) node[above right]{\\text{Mẫu $ B $}};\n`;
                barChart += `\\draw[line cap=round,pattern=dots] (${numRanges * 2 + 3},${maxFrequency + 1})--(${numRanges * 2 + 3},${maxFrequency + 2})--(${numRanges * 2 + 2},${maxFrequency + 2})--(${numRanges * 2 + 2},${maxFrequency + 1})--(${numRanges * 2 + 3},${maxFrequency + 1}) node[above right]{\\text{Mẫu $ A $}};\n`;

                for (let i = 0; i < numRanges; i++) {
                    const x = 2 * i + 1;
                    barChart += `\\draw[line cap=round,pattern=dots] (${x},0)--(${x},${frequenciesA[i]})--(${x + 1},${frequenciesA[i]})node[midway,above]{$ $}--(${x + 1},0)--cycle;\n`;
                    barChart += `\\draw[line cap=round,pattern=north east lines] (${x + 1},0)--(${x + 1},${frequenciesB[i]})--(${x + 2},${frequenciesB[i]})node[midway,above]{$ $}--(${x + 2},0)--cycle;\n`;
                }

                for (let i = 0; i < numRanges; i++) {
                    const x = 2 * i + 2;
                    barChart += `\\node [below] at (${x},0){$ ${heightRanges[i]}$};\n`;
                }

                barChart += `\\draw[->] (0,0)node [below left=-2pt]{$O$}--(${numRanges * 2 + 3},0)node[below]{(\\text{Khoảng})};\n`;
                barChart += `\\end{tikzpicture}\n`;
                barChart += `\\end{center}\n`;


                // Kết hợp kết quả LaTeX
                let result = `\\begin{ex}%[2D4H2-2]\n`;
                result += `Hãy tính giá trị trung bình, phương sai, độ lệch chuẩn, trung vị, mốt, khoảng biến thiên và giá trị ngoại lai của mẫu số liệu ghép nhóm sau Mẫu A và Mẫu B\n`;
                // Thêm biểu đồ cột
                result += barChart;
                // result += `\\begin{center}\n`;
                // result += `\\begin{tabular}{|c|c|c|c|c|c${numRanges > 5 ? '|c'.repeat(numRanges - 5) : ''}|}\n`;
                // result += `\\hline Khoảng giá trị & ${heightRanges.map(range => `{${range}}`).join(' & ')} \\\\\n`;
                // result += `\\hline Tần Số Mẫu A & ${frequenciesA.join(' & ')} \\\\\n`;
                // result += `\\hline Tần Số Mẫu B & ${frequenciesB.join(' & ')} \\\\\n`;
                // result += `\\hline\n`;
                // result += `\\end{tabular}\n`;
                // result += `\\end{center}\n\\loigiai{\n`;
                result += `\\loigiai{\n`;

                // Gộp lời giải cho cả Mẫu A và Mẫu B
                result += `${resultA}${resultB}`;
                result += `}\n`;

                result += `\\end{ex}`;

                return result;
            }
        
        function thongke_4k1_2cot(start, ranges, step, frequenciesA, frequenciesB) {
                // Tạo giá trị đầu tiên của khoảng từ tham số start
                const startHeight = start;
                const numRanges = ranges;

                // Tạo các khoảng chiều cao
            const heightRanges = [];
            for (let i = 0; i < numRanges; i++) {
                const rangeStart = startHeight + i * step;
                const rangeEnd = rangeStart + step;
                const isDecimal = start % 1 !== 0;  // Kiểm tra xem số bắt đầu có phải là số thập phân
                if (isDecimal) {
                    heightRanges.push(`[${rangeStart.toFixed(1)};${rangeEnd.toFixed(1)})`);
                } else {
                    heightRanges.push(`[${Math.round(rangeStart)};${Math.round(rangeEnd)})`);
                }
            }

                // Sử dụng tần số được truyền vào thay vì tạo ngẫu nhiên
                let totalStudentsA = frequenciesA.reduce((acc, freq) => acc + freq, 0);
                let totalStudentsB = frequenciesB.reduce((acc, freq) => acc + freq, 0);

                // Hàm tính toán thống kê cho một mẫu cụ thể
                function calculateStatistics(frequencies, totalStudents, label) {
                    const representativeValues = heightRanges.map(range => {
                        const lowerBound = parseInt(range.split(";")[0].replace("[", ""));
                        const upperBound = parseInt(range.split(";")[1].replace(")", ""));
                        return (lowerBound + upperBound) / 2;
                    });

                    const mean = representativeValues.reduce((acc, value, index) => acc + value * frequencies[index], 0) / totalStudents;
                    const variance = representativeValues.reduce((acc, value, index) => acc + frequencies[index] * Math.pow(value, 2), 0) / totalStudents - Math.pow(mean, 2);
                    const standardDeviation = Math.sqrt(variance);

                    const positionQ1 = totalStudents / 4;
                    const positionQ2 = totalStudents / 2;
                    const positionQ3 = 3 * totalStudents / 4;
                    let cumulativeFrequency = 0;

                    let Q1, Q2, Q3;
                    let Q1Range, Q1Frequency, Q1PreviousCumulative;
                    let Q2Range, Q2Frequency, Q2PreviousCumulative;
                    let Q3Range, Q3Frequency, Q3PreviousCumulative;
                    let Q1BoundaryUsed = false, Q1GroupA, Q1GroupB;
                    let Q3BoundaryUsed = false, Q3GroupA, Q3GroupB;

                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ1 && !Q1) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            if (Math.ceil(positionQ1) - 1 <= previousCumulative || Math.ceil(positionQ1) > cumulativeFrequency) {
                                Q1 = u_m;
                                Q1BoundaryUsed = true;
                                Q1GroupA = heightRanges[i - 1] || heightRanges[i];
                                Q1GroupB = heightRanges[i];
                            } else {
                                Q1 = u_m + ((positionQ1 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            }
                            Q1Range = heightRanges[i];
                            Q1Frequency = frequencies[i];
                            Q1PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ2 && !Q2) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            Q2 = u_m + ((positionQ2 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            Q2Range = heightRanges[i];
                            Q2Frequency = frequencies[i];
                            Q2PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ3 && !Q3) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            if (Math.ceil(positionQ3) <= previousCumulative || Math.ceil(positionQ3) + 1 > cumulativeFrequency) {
                                Q3 = u_m;
                                Q3BoundaryUsed = true;
                                Q3GroupA = heightRanges[i - 1] || heightRanges[i];
                                Q3GroupB = heightRanges[i];
                            } else {
                                Q3 = u_m + ((positionQ3 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            }
                            Q3Range = heightRanges[i];
                            Q3Frequency = frequencies[i];
                            Q3PreviousCumulative = previousCumulative;
                        }
                    }

                    const IQR = Q3 - Q1;
                    const lowerOutlierBound = Q1 - 1.5 * IQR;
                    const upperOutlierBound = Q3 + 1.5 * IQR;

                    const maxFrequency = Math.max(...frequencies);
                    const modeIndex = frequencies.indexOf(maxFrequency);
                    const u_m_mode = parseInt(heightRanges[modeIndex].split(";")[0].replace("[", ""));
                    const u_m1_mode = parseInt(heightRanges[modeIndex].split(";")[1].replace(")", ""));
                    const n_m = frequencies[modeIndex];
                    const n_m_1 = modeIndex > 0 ? frequencies[modeIndex - 1] : 0;
                    const n_m_1_next = modeIndex < frequencies.length - 1 ? frequencies[modeIndex + 1] : 0;
                    const mode = u_m_mode + ((n_m - n_m_1) / ((n_m - n_m_1) + (n_m - n_m_1_next))) * (u_m1_mode - u_m_mode);

                    let result = `\\textbf{${label}}: \\newline\n`;
                    result += `Số trung bình của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ \\overline{x}=\\dfrac{${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}`).join('+')}}{${totalStudents}}=\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}}\\approx ${(mean).toFixed(2)}. $$\n`;
                    result += `Phương sai của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ S^2=\\dfrac{1}{${totalStudents}}(${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}^2`).join('+')})-\\left(\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}} \\right)^2\\approx ${(variance).toFixed(2)}.  $$\n`;
                    result += `Độ lệch chuẩn của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ S\\approx\\sqrt{${(variance).toFixed(2)}}\\approx ${(standardDeviation).toFixed(2)}. $$\n`;

                    result += `Gọi $x_1$; $x_2$; \\ldots; $x_{${totalStudents}}$ là mẫu số liệu gốc gồm $${totalStudents}$ giá trị được xếp theo thứ tự không giảm. Ta có \n`;
                    result += `\\begin{itemize}\n`;
                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        result += `\\item $x_{${cumulativeFrequency - frequencies[i] + 1}}$, \\ldots, $x_{${cumulativeFrequency}} \\in [${heightRanges[i].split(";")[0].replace("[", "")};${heightRanges[i].split(";")[1].replace(")", "")})$; \n`;
                    }
                    result = result.trim();
                    result += `\n\\end{itemize}\n`;

                    // Xác định tứ phân vị thứ nhất (Q1)
                    if (Q1BoundaryUsed) {
                        result += `Tứ phân vị thứ nhất của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ1) - 1}}}$ và $x_{{${Math.ceil(positionQ1)}}}$ mà $x_{{${Math.ceil(positionQ1) - 1}}} \\in [${Q1GroupA.split(";")[0].replace("[", "")};${Q1GroupA.split(";")[1].replace(")", "")})$, $x_{{${Math.ceil(positionQ1)}}} \\in [${Q1GroupB.split(";")[0].replace("[", "")};${Q1GroupB.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ nhất của mẫu số liệu ghép nhóm là biên của nhóm sau:\n`;
                        result += `$$Q_1=${Q1GroupB.split(";")[0].replace("[", "")}$$\n`;
                    } else {
                        result += `Tứ phân vị thứ nhất của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ1) - 1}}}$ và $x_{{${Math.ceil(positionQ1)}}}$ mà $x_{{${Math.ceil(positionQ1) - 1}}}, x_{{${Math.ceil(positionQ1)}}} \\in [${Q1Range.split(";")[0].replace("[", "")};${Q1Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ nhất của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_1=${Q1Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{4}-${Q1PreviousCumulative}}{${Q1Frequency}} \\cdot(${Q1Range.split(";")[1].replace(")", "")}-${Q1Range.split(";")[0].replace("[", "")})\\approx ${(Q1).toFixed(2)}$$\n`;
                    }

                    // Xác định trung vị (Q2)
                    result += `Trung vị của mẫu số liệu gốc là $x_{{${Math.ceil(positionQ2)}}}$ nằm trong nhóm có khoảng $[${Q2Range.split(";")[0].replace("[", "")};${Q2Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                    result += `Do đó, trung vị của mẫu số liệu ghép nhóm là\n`;
                    result += `$$Q_2=${Q2Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{2}-${Q2PreviousCumulative}}{${Q2Frequency}} \\cdot(${Q2Range.split(";")[1].replace(")", "")}-${Q2Range.split(";")[0].replace("[", "")})\\approx ${(Q2).toFixed(2)}$$\n`;

                    // Xác định tứ phân vị thứ ba (Q3)
                    if (Q3BoundaryUsed) {
                        result += `Tứ phân vị thứ ba của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ3)}}}$ và $x_{{${Math.ceil(positionQ3) + 1}}}$ mà $x_{{${Math.ceil(positionQ3)}}} \\in [${Q3GroupA.split(";")[0].replace("[", "")};${Q3GroupA.split(";")[1].replace(")", "")})$, $x_{{${Math.ceil(positionQ3) + 1}}} \\in [${Q3GroupB.split(";")[0].replace("[", "")};${Q3GroupB.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ ba của mẫu số liệu ghép nhóm là biên của nhóm sau:\n`;
                        result += `$$Q_3=${Q3GroupB.split(";")[0].replace("[", "")}$$\n`;
                    } else {
                        result += `Tứ phân vị thứ ba của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ3)}}}$ mà $x_{{${Math.ceil(positionQ3)}}}, x_{{${Math.ceil(positionQ3) + 1}}}$ mà $x_{{${Math.ceil(positionQ3)}}}, x_{{${Math.ceil(positionQ3) + 1}}} \\in [${Q3Range.split(";")[0].replace("[", "")};${Q3Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ ba của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_3=${Q3Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{3\\cdot${totalStudents}}{4}-${Q3PreviousCumulative}}{${Q3Frequency}} \\cdot(${Q3Range.split(";")[1].replace(")", "")}-${Q3Range.split(";")[0].replace("[", "")})\\approx ${(Q3).toFixed(2)}$$\n`;
                    }

                    result += `Vậy khoảng tứ phân vị của mẫu số liệu ghép nhóm là $\\Delta_Q=Q_3-Q_1 \\approx ${(Q3).toFixed(2)}-${(Q1).toFixed(2)}\\approx ${(IQR).toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai thấp hơn ngưỡng dưới là $<${lowerOutlierBound.toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai cao hơn ngưỡng trên là $>${upperOutlierBound.toFixed(2)}$.\\\\\n`;

                    result += `Mốt của mẫu số liệu ghép nhóm là \n`;
                    result += `$$ M_0=${u_m_mode}+\\dfrac{${n_m}-${n_m_1}}{(${n_m}-${n_m_1})+(${n_m}-${n_m_1_next})} \\cdot(${u_m1_mode}-${u_m_mode})\\approx ${(mode).toFixed(2)}$$\n`;

                    return result;
                }

                // Kết quả cho Mẫu A
                const resultA = calculateStatistics(frequenciesA, totalStudentsA, "Mẫu A");

                // Kết quả cho Mẫu B
                const resultB = calculateStatistics(frequenciesB, totalStudentsB, "Mẫu B");
                // Tìm giá trị tần số lớn nhất
                const maxFrequency = Math.max(Math.max(...frequenciesA), Math.max(...frequenciesB)) + 1;

                // Tạo biểu đồ cột
                let barChart = `\\begin{center}\n`;
                barChart += `\\begin{tikzpicture}[>=stealth,line join=round,line cap=round,font=\\footnotesize,scale=0.85,line width=1pt]\n`;
                barChart += `\\draw[->] (0,0)--(0,${maxFrequency + 1})node[left]{(\\text{Tần Số})};\n`;
                for (let y = 1; y <= maxFrequency; y++) {
                    barChart += `\\draw[shift={(0,${y})}] (0,0)--(-2pt,0) node[left]{\\scriptsize $${y}$};\n`;
                }
                barChart += `\\path (5,${maxFrequency + 2}) node {\n`;
                barChart += `\\normalsize{\\textbf{Hai Mẫu Số Liệu $A$ và $B$}}\n`;
                barChart += `};\n`;

                for (let y = 1; y <= maxFrequency; y++) {
                    barChart += `\\draw[dashed,thin,line width=0.01pt] (0,${y})--(${numRanges * 2 + 3},${y});\n`;
                }
                barChart += `\\draw[line cap=round,pattern=north east lines] (${numRanges * 2 + 3},${maxFrequency - 1})--(${numRanges * 2 + 3},${maxFrequency})--(${numRanges * 2 + 2},${maxFrequency})--(${numRanges * 2 + 2},${maxFrequency - 1})--(${numRanges * 2 + 3},${maxFrequency - 1}) node[above right]{\\text{Mẫu $ B $}};\n`;
                barChart += `\\draw[line cap=round,pattern=dots] (${numRanges * 2 + 3},${maxFrequency + 1})--(${numRanges * 2 + 3},${maxFrequency + 2})--(${numRanges * 2 + 2},${maxFrequency + 2})--(${numRanges * 2 + 2},${maxFrequency + 1})--(${numRanges * 2 + 3},${maxFrequency + 1}) node[above right]{\\text{Mẫu $ A $}};\n`;

                for (let i = 0; i < numRanges; i++) {
                    const x = 2 * i + 1;
                    barChart += `\\draw[line cap=round,pattern=dots] (${x},0)--(${x},${frequenciesA[i]})--(${x + 1},${frequenciesA[i]})node[midway,above]{$ $}--(${x + 1},0)--cycle;\n`;
                    barChart += `\\draw[line cap=round,pattern=north east lines] (${x + 1},0)--(${x + 1},${frequenciesB[i]})--(${x + 2},${frequenciesB[i]})node[midway,above]{$ $}--(${x + 2},0)--cycle;\n`;
                }

                for (let i = 0; i < numRanges; i++) {
                    const x = 2 * i + 2;
                    barChart += `\\node [below] at (${x},0){$ ${heightRanges[i]}$};\n`;
                }

                barChart += `\\draw[->] (0,0)node [below left=-2pt]{$O$}--(${numRanges * 2 + 3},0)node[below]{(\\text{Khoảng})};\n`;
                barChart += `\\end{tikzpicture}\n`;
                barChart += `\\end{center}\n`;


                // Kết hợp kết quả LaTeX
                let result = `\\begin{ex}%[2D4H2-2]\n`;
                result += `Hãy tính giá trị trung bình, phương sai, độ lệch chuẩn, trung vị, mốt, khoảng biến thiên và giá trị ngoại lai của mẫu số liệu ghép nhóm sau Mẫu A và Mẫu B\n`;
                // Thêm biểu đồ cột
                result += barChart;
                // result += `\\begin{center}\n`;
                // result += `\\begin{tabular}{|c|c|c|c|c|c${numRanges > 5 ? '|c'.repeat(numRanges - 5) : ''}|}\n`;
                // result += `\\hline Khoảng giá trị & ${heightRanges.map(range => `{${range}}`).join(' & ')} \\\\\n`;
                // result += `\\hline Tần Số Mẫu A & ${frequenciesA.join(' & ')} \\\\\n`;
                // result += `\\hline Tần Số Mẫu B & ${frequenciesB.join(' & ')} \\\\\n`;
                // result += `\\hline\n`;
                // result += `\\end{tabular}\n`;
                // result += `\\end{center}\n\\loigiai{\n`;
                result += `\\loigiai{\n`;

                // Gộp lời giải cho cả Mẫu A và Mẫu B
                result += `${resultA}${resultB}`;
                result += `}\n`;

                result += `\\end{ex}`;

                return result;
            }
        
        function thongke_4k2_2cot(start, ranges, step, frequenciesA, frequenciesB) {
                // Tạo giá trị đầu tiên của khoảng từ tham số start
                const startHeight = start;
                const numRanges = ranges;


                // Tạo các khoảng chiều cao
            const heightRanges = [];
            for (let i = 0; i < numRanges; i++) {
                const rangeStart = startHeight + i * step;
                const rangeEnd = rangeStart + step;
                const isDecimal = start % 1 !== 0;  // Kiểm tra xem số bắt đầu có phải là số thập phân
                if (isDecimal) {
                    heightRanges.push(`[${rangeStart.toFixed(1)};${rangeEnd.toFixed(1)})`);
                } else {
                    heightRanges.push(`[${Math.round(rangeStart)};${Math.round(rangeEnd)})`);
                }
            }
                // Sử dụng tần số được truyền vào thay vì tạo ngẫu nhiên
                let totalStudentsA = frequenciesA.reduce((acc, freq) => acc + freq, 0);
                let totalStudentsB = frequenciesB.reduce((acc, freq) => acc + freq, 0);

                // Hàm tính toán thống kê cho một mẫu cụ thể
                function calculateStatistics(frequencies, totalStudents, label) {
                    const representativeValues = heightRanges.map(range => {
                        const lowerBound = parseInt(range.split(";")[0].replace("[", ""));
                        const upperBound = parseInt(range.split(";")[1].replace(")", ""));
                        return (lowerBound + upperBound) / 2;
                    });

                    const mean = representativeValues.reduce((acc, value, index) => acc + value * frequencies[index], 0) / totalStudents;
                    const variance = representativeValues.reduce((acc, value, index) => acc + frequencies[index] * Math.pow(value, 2), 0) / totalStudents - Math.pow(mean, 2);
                    const standardDeviation = Math.sqrt(variance);

                    const positionQ1 = totalStudents / 4;
                    const positionQ2 = totalStudents / 2;
                    const positionQ3 = 3 * totalStudents / 4;
                    let cumulativeFrequency = 0;

                    let Q1, Q2, Q3;
                    let Q1Range, Q1Frequency, Q1PreviousCumulative;
                    let Q2Range, Q2Frequency, Q2PreviousCumulative;
                    let Q3Range, Q3Frequency, Q3PreviousCumulative;
                    let Q1BoundaryUsed = false, Q2BoundaryUsed = false, Q3BoundaryUsed = false;
                    let Q1GroupA, Q1GroupB, Q2GroupA, Q2GroupB, Q3GroupA, Q3GroupB;

                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ1 && !Q1) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            if (Math.ceil(positionQ1) - 1 <= previousCumulative || Math.ceil(positionQ1) > cumulativeFrequency) {
                                Q1 = u_m;
                                Q1BoundaryUsed = true;
                                Q1GroupA = heightRanges[i - 1] || heightRanges[i];
                                Q1GroupB = heightRanges[i];
                            } else {
                                Q1 = u_m + ((positionQ1 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            }
                            Q1Range = heightRanges[i];
                            Q1Frequency = frequencies[i];
                            Q1PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ2 && !Q2) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            if (Math.ceil(positionQ2) - 1 <= previousCumulative || Math.ceil(positionQ2) > cumulativeFrequency) {
                                Q2 = u_m;
                                Q2BoundaryUsed = true;
                                Q2GroupA = heightRanges[i - 1] || heightRanges[i];
                                Q2GroupB = heightRanges[i];
                            } else {
                                Q2 = u_m + ((positionQ2 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            }
                            Q2Range = heightRanges[i];
                            Q2Frequency = frequencies[i];
                            Q2PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ3 && !Q3) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            if (Math.ceil(positionQ3) <= previousCumulative || Math.ceil(positionQ3) + 1 > cumulativeFrequency) {
                                Q3 = u_m;
                                Q3BoundaryUsed = true;
                                Q3GroupA = heightRanges[i - 1] || heightRanges[i];
                                Q3GroupB = heightRanges[i];
                            } else {
                                Q3 = u_m + ((positionQ3 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            }
                            Q3Range = heightRanges[i];
                            Q3Frequency = frequencies[i];
                            Q3PreviousCumulative = previousCumulative;
                        }
                    }

                    const IQR = Q3 - Q1;
                    const lowerOutlierBound = Q1 - 1.5 * IQR;
                    const upperOutlierBound = Q3 + 1.5 * IQR;

                    const maxFrequency = Math.max(...frequencies);
                    const modeIndex = frequencies.indexOf(maxFrequency);
                    const u_m_mode = parseInt(heightRanges[modeIndex].split(";")[0].replace("[", ""));
                    const u_m1_mode = parseInt(heightRanges[modeIndex].split(";")[1].replace(")", ""));
                    const n_m = frequencies[modeIndex];
                    const n_m_1 = modeIndex > 0 ? frequencies[modeIndex - 1] : 0;
                    const n_m_1_next = modeIndex < frequencies.length - 1 ? frequencies[modeIndex + 1] : 0;
                    const mode = u_m_mode + ((n_m - n_m_1) / ((n_m - n_m_1) + (n_m - n_m_1_next))) * (u_m1_mode - u_m_mode);
                    // Tìm giá trị tần số lớn nhất
                    const maxFrequencyH = Math.max(Math.max(...frequenciesA), Math.max(...frequenciesB)) + 1;

                    // Tạo biểu đồ cột
                    let barChart = `\\begin{center}\n`;
                    barChart += `\\begin{tikzpicture}[>=stealth,line join=round,line cap=round,font=\\footnotesize,scale=0.85,line width=1pt]\n`;
                    barChart += `\\draw[->] (0,0)--(0,${maxFrequencyH + 1})node[left]{(\\text{Tần Số})};\n`;
                    for (let y = 1; y <= maxFrequencyH; y++) {
                        barChart += `\\draw[shift={(0,${y})}] (0,0)--(-2pt,0) node[left]{\\scriptsize $${y}$};\n`;
                    }
                    barChart += `\\path (5,${maxFrequencyH + 2}) node {\n`;
                    barChart += `\\normalsize{\\textbf{Hai Mẫu Số Liệu $A$ và $B$}}\n`;
                    barChart += `};\n`;

                    for (let y = 1; y <= maxFrequencyH; y++) {
                        barChart += `\\draw[dashed,thin,line width=0.01pt] (0,${y})--(${numRanges * 2 + 3},${y});\n`;
                    }
                    barChart += `\\draw[line cap=round,pattern=north east lines] (${numRanges * 2 + 3},${maxFrequencyH - 1})--(${numRanges * 2 + 3},${maxFrequencyH})--(${numRanges * 2 + 2},${maxFrequencyH})--(${numRanges * 2 + 2},${maxFrequencyH - 1})--(${numRanges * 2 + 3},${maxFrequencyH - 1}) node[above right]{\\text{Mẫu $ B $}};\n`;
                    barChart += `\\draw[line cap=round,pattern=dots] (${numRanges * 2 + 3},${maxFrequencyH + 1})--(${numRanges * 2 + 3},${maxFrequencyH + 2})--(${numRanges * 2 + 2},${maxFrequencyH + 2})--(${numRanges * 2 + 2},${maxFrequencyH + 1})--(${numRanges * 2 + 3},${maxFrequencyH + 1}) node[above right]{\\text{Mẫu $ A $}};\n`;

                    for (let i = 0; i < numRanges; i++) {
                        const x = 2 * i + 1;
                        barChart += `\\draw[line cap=round,pattern=dots] (${x},0)--(${x},${frequenciesA[i]})--(${x + 1},${frequenciesA[i]})node[midway,above]{$ $}--(${x + 1},0)--cycle;\n`;
                        barChart += `\\draw[line cap=round,pattern=north east lines] (${x + 1},0)--(${x + 1},${frequenciesB[i]})--(${x + 2},${frequenciesB[i]})node[midway,above]{$ $}--(${x + 2},0)--cycle;\n`;
                    }

                    for (let i = 0; i < numRanges; i++) {
                        const x = 2 * i + 2;
                        barChart += `\\node [below] at (${x},0){$ ${heightRanges[i]}$};\n`;
                    }

                    barChart += `\\draw[->] (0,0)node [below left=-2pt]{$O$}--(${numRanges * 2 + 3},0)node[below]{(\\text{Khoảng})};\n`;
                    barChart += `\\end{tikzpicture}\n`;
                    barChart += `\\end{center}\n`;


                    let result = `\\begin{ex}%[2D4H2-2]\n`;
                    result += `Hãy tính giá trị trung bình, phương sai, độ lệch chuẩn, trung vị, mốt, khoảng biến thiên và giá trị ngoại lai của mẫu số liệu ghép nhóm sau (${label})\n`;
                    // Thêm biểu đồ cột
                    result += barChart;
                    // result += `\\begin{center}\n`;
                    // result += `\\begin{tabular}{|c|c|c|c|c|c${numRanges > 5 ? '|c'.repeat(numRanges - 5) : ''}|}\n`;
                    // result += `\\hline Khoảng giá trị & ${heightRanges.map(range => `{${range}}`).join(' & ')} \\\\\n`;
                    // result += `\\hline Tần Số & ${frequencies.join(' & ')} \\\\\n`;
                    // result += `\\hline\n`;
                    // result += `\\end{tabular}\n`;
                    // result += `\\end{center}\n`;
                    result += `\\loigiai{\n`;
                    result += `Ta có bảng sau\n`;
                    result += `\\begin{center}\n`;
                    result += `\\begin{tabular}{|c|c|c|c|c|c${numRanges > 5 ? '|c'.repeat(numRanges - 5) : ''}|}\n`;
                    result += `\\hline Khoảng giá trị & ${heightRanges.map(range => `{${range}}`).join(' & ')} \\\\\n`;
                    result += `\\hline Giá trị đại diện & ${representativeValues.map(val => val.toFixed(1)).join(' & ')} \\\\\n`;
                    result += `\\hline Tần Số & ${frequencies.join(' & ')} \\\\\n`;
                    result += `\\hline\n`;
                    result += `\\end{tabular}\n`;
                    result += `\\end{center}\n`;
                    result += `Ta có cỡ mẫu $ n=${totalStudents} $.\\\\\n`;
                    result += `Số trung bình của mẫu số liệu ghép nhóm là \n`;
                    result += `$$ \\overline{x}=\\dfrac{${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}`).join('+')}}{${totalStudents}}=\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}}\\approx ${(mean).toFixed(2)}. $$\n`;
                    result += `Phương sai của mẫu số liệu ghép nhóm là  \n`;
                    result += `$$ S^2=\\dfrac{1}{${totalStudents}}(${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}^2`).join('+')})-\\left(\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}} \\right)^2\\approx ${(variance).toFixed(2)}.  $$\n`;
                    result += `Độ lệch chuẩn của mẫu số liệu ghép nhóm là \n`;
                    result += `$$ S\\approx\\sqrt{${(variance).toFixed(2)}}\\approx ${(standardDeviation).toFixed(2)} $$. \n`;

                    result += `Gọi $x_1$; $x_2$; \\ldots; $x_{${totalStudents}}$ là mẫu số liệu gốc gồm $${totalStudents}$ giá trị được xếp theo thứ tự không giảm. Ta có \n`;
                    result += `\\begin{itemize}\n`;
                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        result += `\\item $x_{${cumulativeFrequency - frequencies[i] + 1}}$, \\ldots, $x_{${cumulativeFrequency}} \\in [${heightRanges[i].split(";")[0].replace("[", "")};${heightRanges[i].split(";")[1].replace(")", "")})$; \n`;
                    }
                    result = result.trim();
                    result += `\n\\end{itemize}\n`;

                    if (Q1BoundaryUsed) {
                        result += `Tứ phân vị thứ nhất của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ1) - 1}}}$ và $x_{{${Math.ceil(positionQ1)}}}$ mà $x_{{${Math.ceil(positionQ1) - 1}}} \\in [${Q1GroupA.split(";")[0].replace("[", "")};${Q1GroupA.split(";")[1].replace(")", "")})$, $x_{{${Math.ceil(positionQ1)}}} \\in [${Q1GroupB.split(";")[0].replace("[", "")};${Q1GroupB.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ nhất của mẫu số liệu ghép nhóm là biên của nhóm sau:\n`;
                        result += `$$Q_1=${Q1GroupB.split(";")[0].replace("[", "")}$$\n`;
                    } else {
                        result += `Tứ phân vị thứ nhất của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ1) - 1}}}$ và $x_{{${Math.ceil(positionQ1)}}}$ mà $x_{{${Math.ceil(positionQ1) - 1}}}, x_{{${Math.ceil(positionQ1)}}} \\in [${Q1Range.split(";")[0].replace("[", "")};${Q1Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ nhất của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_1=${Q1Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{4}-${Q1PreviousCumulative}}{${Q1Frequency}} \\cdot(${Q1Range.split(";")[1].replace(")", "")}-${Q1Range.split(";")[0].replace("[", "")})\\approx ${(Q1).toFixed(2)}$$\n`;
                    }

                    result += `Trung vị của mẫu số liệu gốc là $x_{{${Math.ceil(positionQ2)}}}$ nằm trong nhóm có khoảng $[${Q2Range.split(";")[0].replace("[", "")};${Q2Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                    result += `Do đó, trung vị của mẫu số liệu ghép nhóm là\n`;
                    result += `$$Q_2=${Q2Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{2}-${Q2PreviousCumulative}}{${Q2Frequency}} \\cdot(${Q2Range.split(";")[1].replace(")", "")}-${Q2Range.split(";")[0].replace("[", "")})\\approx ${(Q2).toFixed(2)}$$\n`;

                    if (Q3BoundaryUsed) {
                        result += `Tứ phân vị thứ ba của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ3)}}}$ và $x_{{${Math.ceil(positionQ3) + 1}}}$ mà $x_{{${Math.ceil(positionQ3)}}} \\in [${Q3GroupA.split(";")[0].replace("[", "")};${Q3GroupA.split(";")[1].replace(")", "")})$, $x_{{${Math.ceil(positionQ3) + 1}}} \\in [${Q3GroupB.split(";")[0].replace("[", "")};${Q3GroupB.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ ba của mẫu số liệu ghép nhóm là biên của nhóm sau:\n`;
                        result += `$$Q_3=${Q3GroupB.split(";")[0].replace("[", "")}$$\n`;
                    } else {
                        result += `Tứ phân vị thứ ba của mẫu số liệu gốc là trung bình cộng của $x_{{${Math.ceil(positionQ3)}}}$ mà $x_{{${Math.ceil(positionQ3)}}}, x_{{${Math.ceil(positionQ3) + 1}}}$ mà $x_{{${Math.ceil(positionQ3)}}}, x_{{${Math.ceil(positionQ3) + 1}}} \\in [${Q3Range.split(";")[0].replace("[", "")};${Q3Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                        result += `Do đó, tứ phân vị thứ ba của mẫu số liệu ghép nhóm là\n`;
                        result += `$$Q_3=${Q3Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{3\\cdot${totalStudents}}{4}-${Q3PreviousCumulative}}{${Q3Frequency}} \\cdot(${Q3Range.split(";")[1].replace(")", "")}-${Q3Range.split(";")[0].replace("[", "")})\\approx ${(Q3).toFixed(2)}$$\n`;
                    }

                    result += `Vậy khoảng tứ phân vị của mẫu số liệu ghép nhóm là $\\Delta_Q=Q_3-Q_1 \\approx ${(Q3).toFixed(2)}-${(Q1).toFixed(2)}\\approx ${(IQR).toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai thấp hơn ngưỡng dưới là $<${lowerOutlierBound.toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai cao hơn ngưỡng trên là $>${upperOutlierBound.toFixed(2)}$.\\\\\n`;

                    result += `Mốt của mẫu số liệu ghép nhóm là \n`;
                    result += `$$ M_0=${u_m_mode}+\\dfrac{${n_m}-${n_m_1}}{(${n_m}-${n_m_1})+(${n_m}-${n_m_1_next})} \\cdot(${u_m1_mode}-${u_m_mode})\\approx ${(mode).toFixed(2)}$$\n`;

                    result += `}\n`;
                    result += `\\end{ex}`;

                    return result;
                }

                // Kết quả cho Mẫu A
                const resultA = calculateStatistics(frequenciesA, totalStudentsA, "Mẫu A");

                // Kết quả cho Mẫu B
                const resultB = calculateStatistics(frequenciesB, totalStudentsB, "Mẫu B");

                return resultA + "\n" + resultB;
            }
        
        function thongke_4k3_2cot(start, ranges, step, frequenciesA, frequenciesB) {
                // Tạo giá trị đầu tiên của khoảng từ tham số start
                const startHeight = start;
                const numRanges = ranges;


                // Tạo các khoảng chiều cao
            const heightRanges = [];
            for (let i = 0; i < numRanges; i++) {
                const rangeStart = startHeight + i * step;
                const rangeEnd = rangeStart + step;
                const isDecimal = start % 1 !== 0;  // Kiểm tra xem số bắt đầu có phải là số thập phân
                if (isDecimal) {
                    heightRanges.push(`[${rangeStart.toFixed(1)};${rangeEnd.toFixed(1)})`);
                } else {
                    heightRanges.push(`[${Math.round(rangeStart)};${Math.round(rangeEnd)})`);
                }
            }

                // Sử dụng tần số được truyền vào thay vì tạo ngẫu nhiên
                let totalStudentsA = frequenciesA.reduce((acc, freq) => acc + freq, 0);
                let totalStudentsB = frequenciesB.reduce((acc, freq) => acc + freq, 0);

                // Hàm tính toán thống kê cho một mẫu cụ thể
                function calculateStatistics(frequencies, totalStudents, label) {
                    const representativeValues = heightRanges.map(range => {
                        const lowerBound = parseInt(range.split(";")[0].replace("[", ""));
                        const upperBound = parseInt(range.split(";")[1].replace(")", ""));
                        return (lowerBound + upperBound) / 2;
                    });

                    const mean = representativeValues.reduce((acc, value, index) => acc + value * frequencies[index], 0) / totalStudents;
                    const variance = representativeValues.reduce((acc, value, index) => acc + frequencies[index] * Math.pow(value, 2), 0) / totalStudents - Math.pow(mean, 2);
                    const standardDeviation = Math.sqrt(variance);

                    const positionQ1 = totalStudents / 4;
                    const positionQ2 = totalStudents / 2;
                    const positionQ3 = 3 * totalStudents / 4;
                    let cumulativeFrequency = 0;

                    let Q1, Q2, Q3;
                    let Q1Range, Q1Frequency, Q1PreviousCumulative;
                    let Q2Range, Q2Frequency, Q2PreviousCumulative;
                    let Q3Range, Q3Frequency, Q3PreviousCumulative;

                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ1 && !Q1) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            Q1 = u_m + ((positionQ1 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            Q1Range = heightRanges[i];
                            Q1Frequency = frequencies[i];
                            Q1PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ2 && !Q2) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            Q2 = u_m + ((positionQ2 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            Q2Range = heightRanges[i];
                            Q2Frequency = frequencies[i];
                            Q2PreviousCumulative = previousCumulative;
                        }
                    }

                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        if (cumulativeFrequency >= positionQ3 && !Q3) {
                            const previousCumulative = cumulativeFrequency - frequencies[i];
                            const u_m = parseInt(heightRanges[i].split(";")[0].replace("[", ""));
                            const u_m1 = parseInt(heightRanges[i].split(";")[1].replace(")", ""));
                            Q3 = u_m + ((positionQ3 - previousCumulative) / frequencies[i]) * (u_m1 - u_m);
                            Q3Range = heightRanges[i];
                            Q3Frequency = frequencies[i];
                            Q3PreviousCumulative = previousCumulative;
                        }
                    }

                    const IQR = Q3 - Q1;
                    const lowerOutlierBound = Q1 - 1.5 * IQR;
                    const upperOutlierBound = Q3 + 1.5 * IQR;

                    const maxFrequency = Math.max(...frequencies);
                    const modeIndex = frequencies.indexOf(maxFrequency);
                    const u_m_mode = parseInt(heightRanges[modeIndex].split(";")[0].replace("[", ""));
                    const u_m1_mode = parseInt(heightRanges[modeIndex].split(";")[1].replace(")", ""));
                    const n_m = frequencies[modeIndex];
                    const n_m_1 = modeIndex > 0 ? frequencies[modeIndex - 1] : 0;
                    const n_m_1_next = modeIndex < frequencies.length - 1 ? frequencies[modeIndex + 1] : 0;
                    const mode = u_m_mode + ((n_m - n_m_1) / ((n_m - n_m_1) + (n_m - n_m_1_next))) * (u_m1_mode - u_m_mode);

                    let result = `\\textbf{${label}}: \\newline\n`;
                    result += `Số trung bình của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ \\overline{x}=\\dfrac{${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}`).join('+')}}{${totalStudents}}=\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}}\\approx ${(mean).toFixed(2)}. $$\n`;
                    result += `Phương sai của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ S^2=\\dfrac{1}{${totalStudents}}(${frequencies.map((freq, index) => `${freq}\\cdot${representativeValues[index].toFixed(1)}^2`).join('+')})-\\left(\\dfrac{${frequencies.reduce((acc, freq, index) => acc + freq * representativeValues[index], 0)}}{${totalStudents}} \\right)^2\\approx ${(variance).toFixed(2)}.  $$\n`;
                    result += `Độ lệch chuẩn của mẫu số liệu ghép nhóm là\n`;
                    result += `$$ S\\approx\\sqrt{${(variance).toFixed(2)}}\\approx ${(standardDeviation).toFixed(2)}. $$\n`;

                    result += `Gọi $x_1$; $x_2$; \\ldots; $x_{${totalStudents}}$ là mẫu số liệu gốc gồm $${totalStudents}$ giá trị được xếp theo thứ tự không giảm. Ta có \n`;
                    result += `\\begin{itemize}\n`;
                    cumulativeFrequency = 0;
                    for (let i = 0; i < frequencies.length; i++) {
                        cumulativeFrequency += frequencies[i];
                        result += `\\item $x_{${cumulativeFrequency - frequencies[i] + 1}}$, \\ldots, $x_{${cumulativeFrequency}} \\in [${heightRanges[i].split(";")[0].replace("[", "")};${heightRanges[i].split(";")[1].replace(")", "")})$; \n`;
                    }
                    result = result.trim();
                    result += `\n\\end{itemize}\n`;

                    // Xác định tứ phân vị thứ nhất (Q1)
                    result += `Tứ phân vị thứ nhất của mẫu số liệu gốc là $x_{{${Math.ceil(positionQ1)}}}$ nằm trong nhóm có khoảng $[${Q1Range.split(";")[0].replace("[", "")};${Q1Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                    result += `Do đó, tứ phân vị thứ nhất của mẫu số liệu ghép nhóm là\n`;
                    result += `$$Q_1=${Q1Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{4}-${Q1PreviousCumulative}}{${Q1Frequency}} \\cdot(${Q1Range.split(";")[1].replace(")", "")}-${Q1Range.split(";")[0].replace("[", "")})\\approx ${(Q1).toFixed(2)}$$\n`;

                    // Xác định trung vị (Q2)
                    result += `Trung vị của mẫu số liệu gốc là $x_{{${Math.ceil(positionQ2)}}}$ nằm trong nhóm có khoảng $[${Q2Range.split(";")[0].replace("[", "")};${Q2Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                    result += `Do đó, trung vị của mẫu số liệu ghép nhóm là\n`;
                    result += `$$Q_2=${Q2Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{${totalStudents}}{2}-${Q2PreviousCumulative}}{${Q2Frequency}} \\cdot(${Q2Range.split(";")[1].replace(")", "")}-${Q2Range.split(";")[0].replace("[", "")})\\approx ${(Q2).toFixed(2)}$$\n`;

                    // Xác định tứ phân vị thứ ba (Q3)
                    result += `Tứ phân vị thứ ba của mẫu số liệu gốc là $x_{{${Math.ceil(positionQ3)}}}$ nằm trong nhóm có khoảng $[${Q3Range.split(";")[0].replace("[", "")};${Q3Range.split(";")[1].replace(")", "")})$.\\\\\n`;
                    result += `Do đó, tứ phân vị thứ ba của mẫu số liệu ghép nhóm là\n`;
                    result += `$$Q_3=${Q3Range.split(";")[0].replace("[", "")}+\\dfrac{\\dfrac{3\\cdot${totalStudents}}{4}-${Q3PreviousCumulative}}{${Q3Frequency}} \\cdot(${Q3Range.split(";")[1].replace(")", "")}-${Q3Range.split(";")[0].replace("[", "")})\\approx ${(Q3).toFixed(2)}$$\n`;

                    result += `Vậy khoảng tứ phân vị của mẫu số liệu ghép nhóm là $\\Delta_Q=Q_3-Q_1 \\approx ${(Q3).toFixed(2)}-${(Q1).toFixed(2)}\\approx ${(IQR).toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai thấp hơn ngưỡng dưới là $<${lowerOutlierBound.toFixed(2)}$.\\\\\n`;
                    result += `Giá trị ngoại lai cao hơn ngưỡng trên là $>${upperOutlierBound.toFixed(2)}$.\\\\\n`;

                    result += `Mốt của mẫu số liệu ghép nhóm là \n`;
                    result += `$$ M_0=${u_m_mode}+\\dfrac{${n_m}-${n_m_1}}{(${n_m}-${n_m_1})+(${n_m}-${n_m_1_next})} \\cdot(${u_m1_mode}-${u_m_mode})\\approx ${(mode).toFixed(2)}$$\n`;

                    return result;
                }

                // Kết quả cho Mẫu A
                const resultA = calculateStatistics(frequenciesA, totalStudentsA, "Mẫu A");

                // Kết quả cho Mẫu B
                const resultB = calculateStatistics(frequenciesB, totalStudentsB, "Mẫu B");
                // Tìm giá trị tần số lớn nhất
                const maxFrequencyH = Math.max(Math.max(...frequenciesA), Math.max(...frequenciesB)) + 1;
                // Tạo biểu đồ cột
                let barChart = `\\begin{center}\n`;
                barChart += `\\begin{tikzpicture}[>=stealth,line join=round,line cap=round,font=\\footnotesize,scale=0.85,line width=1pt]\n`;
                barChart += `\\draw[->] (0,0)--(0,${maxFrequencyH + 1})node[left]{(\\text{Tần Số})};\n`;
                for (let y = 1; y <= maxFrequencyH; y++) {
                    barChart += `\\draw[shift={(0,${y})}] (0,0)--(-2pt,0) node[left]{\\scriptsize $${y}$};\n`;
                }
                barChart += `\\path (5,${maxFrequencyH + 2}) node {\n`;
                barChart += `\\normalsize{\\textbf{Hai Mẫu Số Liệu $A$ và $B$}}\n`;
                barChart += `};\n`;

                for (let y = 1; y <= maxFrequencyH; y++) {
                    barChart += `\\draw[dashed,thin,line width=0.01pt] (0,${y})--(${numRanges * 2 + 3},${y});\n`;
                }
                barChart += `\\draw[line cap=round,pattern=north east lines] (${numRanges * 2 + 3},${maxFrequencyH - 1})--(${numRanges * 2 + 3},${maxFrequencyH})--(${numRanges * 2 + 2},${maxFrequencyH})--(${numRanges * 2 + 2},${maxFrequencyH - 1})--(${numRanges * 2 + 3},${maxFrequencyH - 1}) node[above right]{\\text{Mẫu $ B $}};\n`;
                barChart += `\\draw[line cap=round,pattern=dots] (${numRanges * 2 + 3},${maxFrequencyH + 1})--(${numRanges * 2 + 3},${maxFrequencyH + 2})--(${numRanges * 2 + 2},${maxFrequencyH + 2})--(${numRanges * 2 + 2},${maxFrequencyH + 1})--(${numRanges * 2 + 3},${maxFrequencyH + 1}) node[above right]{\\text{Mẫu $ A $}};\n`;

                for (let i = 0; i < numRanges; i++) {
                    const x = 2 * i + 1;
                    barChart += `\\draw[line cap=round,pattern=dots] (${x},0)--(${x},${frequenciesA[i]})--(${x + 1},${frequenciesA[i]})node[midway,above]{$ $}--(${x + 1},0)--cycle;\n`;
                    barChart += `\\draw[line cap=round,pattern=north east lines] (${x + 1},0)--(${x + 1},${frequenciesB[i]})--(${x + 2},${frequenciesB[i]})node[midway,above]{$ $}--(${x + 2},0)--cycle;\n`;
                }

                for (let i = 0; i < numRanges; i++) {
                    const x = 2 * i + 2;
                    barChart += `\\node [below] at (${x},0){$ ${heightRanges[i]}$};\n`;
                }

                barChart += `\\draw[->] (0,0)node [below left=-2pt]{$O$}--(${numRanges * 2 + 3},0)node[below]{(\\text{Khoảng})};\n`;
                barChart += `\\end{tikzpicture}\n`;
                barChart += `\\end{center}\n`;
                // Kết hợp kết quả LaTeX
                let result = `\\begin{ex}%[2D4H2-2]\n`;
                result += `Hãy tính giá trị trung bình, phương sai, độ lệch chuẩn, trung vị, mốt, khoảng biến thiên và giá trị ngoại lai của mẫu số liệu ghép nhóm sau Mẫu A và Mẫu B\n`;
                result += barChart;
                // result += `\\begin{center}\n`;
                // result += `\\begin{tabular}{|c|c|c|c|c|c${numRanges > 5 ? '|c'.repeat(numRanges - 5) : ''}|}\n`;
                // result += `\\hline Khoảng giá trị & ${heightRanges.map(range => `{${range}}`).join(' & ')} \\\\\n`;
                // result += `\\hline Tần Số Mẫu A & ${frequenciesA.join(' & ')} \\\\\n`;
                // result += `\\hline Tần Số Mẫu B & ${frequenciesB.join(' & ')} \\\\\n`;
                // result += `\\hline\n`;
                // result += `\\end{tabular}\n`;
                // result += `\\end{center}\n\\loigiai{\n`;
                result += `\\loigiai{\n`;

                // Gộp lời giải cho cả Mẫu A và Mẫu B
                result += `${resultA}${resultB}`;
                result += `}\n\\end{ex}`;

                return result;
            }
        
        function copyResult() {
                const resultText = document.getElementById("result");
                resultText.select();
                resultText.setSelectionRange(0, 99999);

                document.execCommand("copy");

                // Hiển thị hộp thoại tùy chỉnh
                const dialog = document.getElementById("copyDialog");
                dialog.style.display = "flex";

                // Đóng hộp thoại sau 2 giây
                setTimeout(closeDialog, 2000);
            }

            function closeDialog() {
                const dialog = document.getElementById("copyDialog");
                dialog.style.display = "none";
            }

    </script>
</body>

</html>
